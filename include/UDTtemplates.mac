#include "Templates.mac"

/******************************************************************************
 *
 * Array-extensions for binary monary ops.
 *
 * Calls of these are created when using the macros provided in "Templates.mac"
 * such as MAP_ARI_OPS, MAP_INT_OPS, MAP_REL_OPS, etc.
 *
 ******************************************************************************/

#define MAP_BIN_AxA( name, op, a, b)                                           \
inline                                                                         \
b[+] name( a[+] A, a[+] B)                                                     \
{                                                                              \
  shp = shape( A);                                                             \
  res = with {                                                                 \
          ( . <= iv <= . )                                                     \
            : name ( sel( iv, A), sel( iv, B));                                \
        } : genarray( shp, name( one( A), one( B)));                           \
  return( res);                                                                \
}

#define MAP_BIN_AxS( name, op, a, b)                                           \
inline                                                                         \
b[+] name( a[+] A, a B)                                                        \
{                                                                              \
  shp = shape( A);                                                             \
  res = with {                                                                 \
          ( . <= iv <= . )                                                     \
            : name ( sel( iv, A), B);                                          \
        } : genarray( shp, name( one( A), one( B)));                           \
  return( res);                                                                \
}

#define MAP_BIN_SxA( name, op, a, b)                                           \
inline                                                                         \
b[+] name( a A, a[+] B)                                                        \
{                                                                              \
  shp = shape( B);                                                             \
  res = with {                                                                 \
          ( . <= iv <= . )                                                     \
            : name ( A, sel( iv, B));                                          \
        } : genarray( shp, name( one( A), one( B)));                           \
  return( res);                                                                \
}


/******************************************************************************
 *
 * Array-extensions for monadic ops.
 *
 * Calls of these are created when using the macros provided in "Templates.mac"
 * such as MAP_ARI_OPS, MAP_INT_OPS, MAP_REL_OPS, etc.
 *
 ******************************************************************************/

#define MAP_MON_AxA( name, op, a, b)                                           \
inline                                                                         \
b[+] name( a[+] A)                                                             \
{                                                                              \
  shp = shape( A);                                                             \
  res = with {                                                                 \
          ( . <= iv <= . )                                                     \
            : name ( sel( iv, A));                                             \
        } : genarray( shp, name( zero( A)));                                   \
  return( res);                                                                \
}

#define MAP_MON_SxA( name, op, a, b)
#define MAP_MON_AxS( name, op, a, b)


/******************************************************************************
 *
 * AriOPS on arrays (see Templates.mac for details).
 *
 ******************************************************************************/

#define ARI_OPS_A( a)                                                          \
MAP_ARI_OPS( AxA, a)                                                           \
MAP_ARI_OPS( SxA, a)                                                           \
MAP_ARI_OPS( AxS, a)


/******************************************************************************
 *
 * RelOPS on arrays (see Templates.mac for details).
 *
 ******************************************************************************/

#define REL_OPS_A( a)                                                          \
EQ_OPS_A( a)                                                                   \
COMP_OPS_A( a)

#define EQ_OPS_A( a)                                                           \
MAP_EQ_OPS( AxA, a)                                                            \
MAP_EQ_OPS( SxA, a)                                                            \
MAP_EQ_OPS( AxS, a)

#define COMP_OPS_A( a)                                                         \
MAP_COMP_OPS( AxA, a)                                                          \
MAP_COMP_OPS( SxA, a)                                                          \
MAP_COMP_OPS( AxS, a)


/******************************************************************************
 *
 * Structural OPS.
 *
 ******************************************************************************/

#define TAKE_VxA( a)                                                           \
inline                                                                         \
a[n:v, m:ishp] take(int[n] v, a[n:oshp, m:ishp] array)                         \
//******************************************************************************
// The classic take, takes the first v elements of the given array.
// In case v has a negative number, the last |v| elements will be given instead.
// Extra elements are noted as a 0.
//******************************************************************************
{                                                                              \
  // Start shows the index of the first element to be selected.                \
  start = ArrayTransform::where( _lt_VxS_(v, 0),                               \
            _add_VxV_( oshp, v),                                               \
            0);                                                                \
  // Stop signals the location of the last index element of array.             \
  // This can be longer than the size of the array, in case start              \
  // is less than (-oshp).                                                     \
  stop = ArrayTransform::where( _lt_VxS_(v, 0),                                \
           _abs_V_(v),                                                         \
           _min_VxV_( _abs_V_(v), oshp));                                      \
  // The result is calculated in 3 steps:                                      \
  res = {// 1: prepend zeros (if needed)                                       \
         iv -> genarray(ishp, zero(array)) | iv < _neg_V_(start);              \
         // 2: select the required elements of the array                       \
         iv -> array[ _add_VxV_( start, iv)] | iv < stop;                      \
         // 3: add zeros at the end (if needed)                                \
         iv -> genarray(ishp, zero(array)) | iv < _abs_V_(v)};                 \
  return(res);                                                                 \
}                                                                              \

#define TAKE( a)                                                               \
TAKE_VxA( a)

/******************************************************************************/

#define DROP_VxA( a)                                                           \
inline                                                                         \
a[n:shp_res, m:ishp] drop( int[n] v, a[n:oshp, m:ishp] array)                  \
//******************************************************************************
// The classic drop, removes the first v elements of the given array.
// In case v has a negative number, the last |v| elements will be removed instead.
// For |v| larger than oshp, an array of shape (n:zeroes, m:ishp) will be returned,
// Which, of course, has no data.
// Similar to take(-v, array).
//******************************************************************************                           
{                                                                              \
  // Calculate shape of result array.                                          \
  shp_res = _sub_VxV_(oshp, _abs_V_(v));                                       \
  shp_res = ArrayTransform::where( _lt_VxS_(shp_res, 0), 0, shp_res);          \
  // Start shows the index of the first element to be selected.                \
  start = ArrayTransform::where( _lt_VxS_(v, 0), 0, v);                        \
  // Select the requested elements of array.                                   \
  res = { iv -> array[_add_VxV_( start, iv)] | iv < shp_res };                 \
  return(res);                                                                 \
}                                                                              \

#define DROP( a)                                                               \
DROP_VxA( a)

/******************************************************************************/

#define TILE_VxVxA( a)                                                         \
inline                                                                         \

a[n:shp] tile( int[n] shp, int[n] idx, a[n:shp_a] array)                       \
| _all_V_( _ge_VxS_(shp, 0))                                                   \
//******************************************************************************
// Takes shp elements of the given array, starting at idx. Elements outside
// of the array are marked as a zero.
//****************************************************************************** 
{                                                                              \
  // Start shows how many elements we prepend before the array.                \
  start = ArrayTransform::where( _lt_VxS_(idx, 0),                             \
           _abs_V_(idx),                                                       \
           0);                                                                 \
  // Stop shows where our selection of the given array ends, or, in case       \
  // the selection goes beyond the array, where the array ends.                \
  stop = _min_VxV_(shp, _sub_VxV_(shp_a, idx));                                \
  // The result is calculated in 2 steps:                                      \
  res = {// 1: select the required elements of the array                       \
         iv -> array[ _add_VxV_(idx, iv)] | start <= iv < stop;                \
         // 2: add zeros around (if needed)                                    \
         iv -> zero(array) | iv < shp};                                        \
  return( res);                                                                \
}

#define TILE( a)                                                               \
TILE_VxVxA( a)

/******************************************************************************/

#define CAT_AxA( a)                                                            \
inline                                                                         \
a[oshp, n:ishp] ++ ( a[oshp_a, n:ishp] arr_a, a[oshp_b, n:ishp] arr_b)         \
//******************************************************************************
// The classic concatenate. Appends the array b to the array a.
//******************************************************************************
{                                                                              \
  // Calculate the resulting shape.                                            \
  oshp = _add_SxS_(oshp_a, oshp_b);                                            \
  // The result is calculated in 2 steps:                                      \
  res = {// 1: take array a.                                                   \
         [i] -> arr_a[i] | [i] < [oshp_a];                                     \
         // 2: append array b.                                                 \
         [i] -> arr_b[ _sub_SxS_(i, oshp_a)] | [i] < [oshp]};                  \
  return( res);                                                                \
}                                                                              \

#define CAT( a)                                                                \
CAT_AxA( a)

/******************************************************************************/

#define REVERSE_A( a)                                                          \
inline                                                                         \
a[oshp, n:ishp] reverse( a[oshp, n:ishp] array)                                \
//******************************************************************************
// The classic reverse. Reverses the given array over the outermost dimension.
//******************************************************************************
{                                                                              \
  // Stop shows the index of the last element of array.                        \
  stop = _sub_SxS_(oshp, 1);                                                   \
  res = {[i] -> array[_sub_SxS_(stop, i)] | [i] < [oshp]};                     \
  return( res);                                                                \
}                                                                              \

#define REVERSE( a)                                                            \
REVERSE_A( a)

/******************************************************************************/

#define SHIFT_S( a)                                                            \
inline                                                                         \
a[+] shift (int dimension, int count, a boundary, a[+] A)                      \
{                                                                              \
  if (count ScalarArith::== 0) {                                               \
    result = A;                                                                \
  } else {                                                                     \
    max_shift = _sel_VxA_( [dimension], shape(A));                             \
                                                                               \
    if (count ScalarArith::> 0) {                                              \
      count = _min_SxS_( count, max_shift);                                    \
      offset = _modarray_AxVxS_( _mul_SxV_( 0, shape(A)), [dimension], count); \
      lb = offset;                                                             \
      ub = shape(A);                                                           \
    } else {                                                                   \
      count = _max_SxS_( count, _neg_S_(max_shift));                           \
      offset = _modarray_AxVxS_( _mul_SxV_( 0, shape(A)), [dimension], count); \
      lb = _mul_SxV_( 0, shape(A));                                            \
      ub = _add_VxV_( shape(A), offset);                                       \
    }                                                                          \
                                                                               \
    result = with {                                                            \
               ( . <= iv <= . ) : boundary;                                    \
             } : genarray( shape(A), zero(A) );                                \
                                                                               \
    result = with {                                                            \
               ( lb <= iv < ub ) : sel( _sub_VxV_( iv, offset), A);            \
             } : modarray( result );                                           \
  }                                                                            \
  return(result);                                                              \
}

#define SHIFT_V( a)                                                            \
inline                                                                         \
a[+] shift (int[.] counts, a boundary, a[+] A)                                 \
{                                                                              \
  for( i=0;                                                                    \
       i ScalarArith::<_sel_VxA_( [0], _shape_A_(counts));                     \
       i=i ScalarArith::+1) {                                                  \
    offset = _sel_VxA_([i], counts);                                           \
    A = shift( i, offset, boundary, A);                                        \
  }                                                                            \
  return(A);                                                                   \
}

#define SHIFT_V_Z( a)                                                          \
inline                                                                         \
a[*] shift (int[.] counts, a[+] A)                                             \
{                                                                              \
  return( shift ( counts, zero(A), A));                                        \
}

#define SHIFT( a)                                                              \
SHIFT_S( a)                                                                    \
SHIFT_V( a)                                                                    \
SHIFT_V_Z( a)

/******************************************************************************/

#define ROTATE_S( a)                                                           \
inline                                                                         \
a[+] rotate (int dimension, int count, a[+] A)                                 \
{                                                                              \
  if(count ScalarArith::== 0) {                                                \
    result = A;                                                                \
  } else {                                                                     \
    max_rotate = _sel_VxA_( [dimension], shape(A));                            \
    if( _eq_SxS_( max_rotate, 0)) {                                            \
      result = A;                                                              \
    } else {                                                                   \
      count = _mod_SxS_( count, max_rotate);                                   \
      if (_lt_SxS_(count, 0)) {                                                \
        count = _add_SxS_( count, max_rotate);                                 \
      }                                                                        \
                                                                               \
      offset = _modarray_AxVxS_(_mul_SxV_( 0, shape(A)),[dimension],count);    \
      slice_shp = _modarray_AxVxS_(shape(A), [dimension], count);              \
                                                                               \
      result = with {                                                          \
                 (offset <= iv < shape(A)) : sel(_sub_VxV_(iv,offset), A);     \
               } : modarray(A);                                                \
                                                                               \
      result = with {                                                          \
                 (_mul_SxV_(0,shape(result)) <= iv <  slice_shp)               \
                 : sel(shape(A)                                                \
                       ArrayArith::- slice_shp                                 \
                       ArrayArith::+ iv, A);                                   \
               } : modarray( result );                                         \
    }                                                                          \
  }                                                                            \
  return(result);                                                              \
}

#define ROTATE_V( a)                                                           \
inline                                                                         \
a[+] rotate (int[.] counts,  a[+] A)                                           \
{                                                                              \
  for( i=0; _lt_SxS_(i, _sel_VxA_( [0], _shape_A_(counts)));                   \
       i=_add_SxS_(i,1)) {                                                     \
    offset = _sel_VxA_( [i], counts);                                          \
    A = rotate( i, offset, A);                                                 \
  }                                                                            \
  return(A);                                                                   \
}

#define ROTATE( a)                                                             \
ROTATE_S( a)                                                                   \
ROTATE_V( a)
