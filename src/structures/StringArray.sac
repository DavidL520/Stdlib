module StringArray;

use String : {string};
use Array : {*,all};
/*export all except {eq_SxS, eq_SxA, eq_AxS, eq_AxA, getIndicies, 
                   modarray_AxVxS, sel_VxA, stringArrayCreator};*/
export all except {eq_SxS, eq_SxA, eq_AxS, eq_AxA, getIndicies, 
                   modarray_AxVxS, sel_VxA};

/*
 * You can create a new stringArray using:
 *   genarray( shp, to_stringArray( "default string")
 *   
 * Modarray and sel work as usual and return stringarrays. Use to_string to 
 * get a string back out of a scalar stringarray.
 */

external typedef stringArray;
    #pragma linkobj "src/StringArray/free.o"
    #pragma linkobj "src/StringArray/copy.o"
    #pragma linkobj "src/StringArray/alloc.o"
    #pragma freefun "SAC_StringArray_free"
    #pragma copyfun "SAC_StringArray_copy"

external stringArray modarray_AxVxS( stringArray labs, int[.] idx, string  str);
    #pragma linkname "SAC_StringArray_modarray"
    #pragma linkobj "src/StringArray/modarray.o"
    #pragma linkobj "src/StringArray/index2offset.o"
    #pragma refcounting [0,1,2,3]

stringArray modarray( stringArray array, int[.] idx, stringArray val)
{
  if( Array::sel( [0], Array::shape( idx)) Array::== dim( array)) {
    if( Array::!=( dim( val), 0)) {
      RuntimeError::error( 1, 
          "Attempt to use StringArray::modarray to replace scalar subarray with non-scalar");
    }
    res = modarray_AxVxS( array, idx, sel_VxA( [], val));
  } 
  else if( Array::sel( [0], Array::shape( idx)) Array::< dim( array)) {
    if( Array::any( 
          shape( val) Array::!= Array::drop( [Array::sel( [0], Array::shape( idx))], 
                                             shape(array)))) {
      RuntimeError::error( 1, 
          "Attempt to use StringArray::modarray to replace subarray with an array of a different shape");
    }
    val_shp = Array::drop( [Array::sel( [0], Array::shape( idx))], 
                           shape( array));
    indicies = getIndicies( val_shp);
    res = array;
    ub = Array::sel( [0], Array::shape(indicies));
    i=0;
    while( i Array::< ub) {
       /*  <---- Falls over inh here somewhere  */
      selection = Array::sel( [i], indicies);
      modarrayidx = idx Array::++ selection;
      modArrVal = sel_VxA( Array::sel( [i], indicies), val);
      res = modarray_AxVxS( res, modarrayidx, modArrVal);
      i = i Array::+ 1;
    }
  }
  else {
    res = array;
    RuntimeError::error( 1, "Overlarge index vector passed to stringArray::modarray");
  }
  return( res);
}

external string sel_VxA( int[.] idx, stringArray labs);
    #pragma linkname "SAC_StringArray_sel"
    #pragma linkobj "src/StringArray/sel.o"
    #pragma linkobj "src/StringArray/index2offset.o"
    #pragma refcounting [0,1,2]

stringArray sel( int[.] idx, stringArray array)
{
  if( Array::sel( [0], Array::shape( idx)) Array::== dim( array)) {
    res = genarray( [], to_stringArray( sel_VxA( idx, array)));
  } 
  else if( Array::sel( [0], Array::shape( idx)) Array::< dim( array)) {
    idx_len = Array::sel( [0], Array::shape( idx));
    res_shp = Array::drop( [ idx_len ], shape( array));
    if( Array::sel( [0], res_shp) Array::== 0) {
      RuntimeError::error( 1, "res_shape is [0]");
    }
    res = genarray( res_shp, to_stringArray( ""));

    indicies = getIndicies( shape( res));
    for( i=0 ; i Array::< Array::sel( [0], Array::shape(indicies)); i = i Array::+ 1) {
      res = modarray( res, Array::sel( [i], indicies), 
                      sel( idx Array::++ Array::sel( [i], indicies), array));
    }
  }
  else {
    res = array;
    RuntimeError::error( 1, 
        "Attempt to select into a stringArray with an index vector longer than the stringArray's dimensionality");
  }
  return( res);
}

string to_string( stringArray a)
{
  /*
  if( dim( a) Array::!= 0) {
    RuntimeError::error( 1,
        "to_string passed non-scalar stringArray");
  }
  */
  return( sel_VxA( [], a));
}

stringArray to_stringArray( string s)
{
  return( stringArrayCreator( [], s));
}

external int dim( stringArray s);
    #pragma linkname "SAC_StringArray_dim"
    #pragma linkobj "src/StringArray/dim.o"
    #pragma refcounting [0,1]

external int[.] shape( stringArray s);
    #pragma linkname "SAC_StringArray_shape"
    #pragma linkobj "src/StringArray/shape.o"
    #pragma refcounting [0,1]


external stringArray stringArrayCreator( int[.] shp, string s);
    #pragma linkname "SAC_StringArray_genarray"
    #pragma linkobj "src/StringArray/genarray.o"
    #pragma refcounting [0,1,2]

stringArray genarray( int[.] shp, stringArray s)
{
  new_shp = shp Array::++ shape( s);
  res = stringArrayCreator( new_shp, "");
  indicies = getIndicies( shp);
  for( i=0 ; i Array::< Array::sel( [0], Array::shape( indicies)) ; i = i Array::+ 1) {
    res = modarray( res, Array::sel( [i], indicies), s);
  }
  return( res);
}

inline
bool eq_SxS ( stringArray a, stringArray b)
{
  return( to_string( a) String::== to_string( b));
}

inline
bool[*] eq_SxA( stringArray a, stringArray b)
{
  res = with {
          ( 0* shape(b) <= iv < shape(b)) : to_string( a) String::== sel_VxA( iv, b);
        } : genarray( shape( b), true);
  return( res);
}

inline
bool[*] eq_AxS( stringArray a, stringArray b)
{
  res = with {
          ( 0* shape(a) <= iv < shape(a)) : sel_VxA( iv, a) String::== to_string( b);
        } : genarray( shape( a), true);
  return( res);
}

inline
bool[*] eq_AxA( stringArray a, stringArray b)
{
  res = with {
          ( 0* shape(b) <= iv < shape(b)) : sel_VxA( iv, a) String::== sel_VxA( iv, b);
        } : genarray( shape( b), true);
  return( res);
}

inline
bool[*] (==)( stringArray a, stringArray b)
{
  if( dim(a) ScalarArith::== 0) {
    if( dim( b) ScalarArith::== 0 ) {
      res = eq_SxS( a, b);
    } else {
      res = eq_SxA( a, b);
    }
  } else {
    if( dim(b) ScalarArith::== 0) {
      res = eq_AxS( a, b);
    } else if( all( shape( a) Array::== shape(b))) {
      res = eq_AxA( a, b);
    } else {
      RuntimeError::error( 1, "(==) applied to arrays of different shape!");
      res = false;
    }
  }
  return( res);
}
/*
int[.,.] getIndicies( int[.] shp)
{
  iota_shp = Array::iota( shp);
  return( 
    Array::reshape( [ Array::prod( Array::take( [ Array::dim( Array::iota( shp)) Array::- 1 ], Array::shape( iota_shp))), 
                      Array::sel( [0], Array::reverse( Array::shape( shp))) ], 
                    iota_shp));
}
*/
inline
int[.,.] getIndicies( int[.] shp)
{
    iota_shp = Array::iota( shp);
      return(
              Array::reshape( [ Array::prod( Array::take( [ Array::dim( Array::iota( shp)) Array::- 1 ], Array::shape( iota_shp))),
                                      Array::sel( [0], Array::reverse( Array::shape( shp))) ],
                                                          iota_shp));
}

/* wrong result
int[.,.] getIndicies( int[.] shp)
{
  return( 
    Array::reshape( [ Array::prod( Array::drop( [0 Array::- 1], Array::iota( shp))), 
                      Array::sel( [0], Array::shape( shp)) ], 
                    Array::iota( shp)));
}
*/


stringArray modLoop( int[.] shp, stringArray array, 
                     int[.] indexPrefix, stringArray val)
{
  indicies = getIndicies( shp);
  ub = Array::sel( [0], Array::shape(indicies));
  i = 0;
  while( i Array::< ub) {
      /* <---- Falls over inh here somewhere   */
    selection = Array::sel( [i], indicies);
    RuntimeError::error( 1, "hhhj");
    modarrayidx = indexPrefix Array::++ selection;
    modArrVal = sel_VxA( Array::sel( [i], indicies), val);
    array = modarray_AxVxS( array, modarrayidx, modArrVal);
    i = i Array::+ 1;
  }
  return( array);
}
