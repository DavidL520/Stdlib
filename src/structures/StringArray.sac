module StringArray;

use String : {string};
use Array : {*,all};

export all except {eq_SxS, eq_SxA, eq_AxS, eq_AxA};

external typedef stringArray;
    #pragma linkobj "src/StringArray/free.o"
    #pragma linkobj "src/StringArray/copy.o"
    #pragma linkobj "src/StringArray/alloc.o"
    #pragma freefun "SAC_StringArray_free"
    #pragma copyfun "SAC_StringArray_copy"

external stringArray modarray_VxAxS( stringArray labs, int[.] idx, string  str);
    #pragma linkname "SAC_StringArray_modarray"
    #pragma linkobj "src/StringArray/modarray.o"
    #pragma linkobj "src/StringArray/index2offset.o"
    #pragma refcounting [0,1,2,3]

stringArray modarray( stringArray array, int[.] idx, stringArray val)
{
  if( Array::sel( [0], Array::shape( idx)) Array::== dim( array)) {
    /* check dim( val) == 0! */
    res = modarray_VxAxS( array, idx, sel_VxA( [], val));
  } else {
    res = array;
    /** horrid for-loop missing which uses modarray_VxAxS */
  }
  return( res);
}

external string sel_VxA( int[.] idx, stringArray labs);
    #pragma linkname "SAC_StringArray_sel"
    #pragma linkobj "src/StringArray/sel.o"
    #pragma linkobj "src/StringArray/index2offset.o"
    #pragma refcounting [0,1,2]

stringArray sel( int[.] idx, stringArray array)
{
  if( Array::sel( [0], Array::shape( idx)) Array::== dim( array)) {
    res = genarray( [], sel_VxA( idx, array));
  } else {
    res_shp = _drop_SxV_( Array::sel( [0], Array::shape( idx)), shape( array));
    res = genarray( res_shp, "");
    /** horrid for-loop missing which uses modarray_VxAxS */
  }
  return( res);
}

string tos( stringArray a)
{
  /* check dim( a) == 0 */
  return( sel_VxA( [], a));
}

external int dim( stringArray s);
    #pragma linkname "SAC_StringArray_dim"
    #pragma linkobj "src/StringArray/dim.o"
    #pragma refcounting [0,1]

external int[.] shape( stringArray s);
    #pragma linkname "SAC_StringArray_shape"
    #pragma linkobj "src/StringArray/shape.o"
    #pragma refcounting [0,1]


external stringArray genarray( int[.] shp, string s);
    #pragma linkname "SAC_StringArray_genarray"
    #pragma linkobj "src/StringArray/genarray.o"
    #pragma refcounting [0,1,2]

inline
bool eq_SxS ( stringArray a, stringArray b)
{
  return( tos( a) String::== tos( b));
}

inline
bool[*] eq_SxA( stringArray a, stringArray b)
{
  res = with {
          ( 0* shape(b) <= iv < shape(b)) : tos( a) String::== sel_VxA( iv, b);
        } : genarray( shape( b), true);
  return( res);
}

inline
bool[*] eq_AxS( stringArray a, stringArray b)
{
  res = with {
          ( 0* shape(a) <= iv < shape(a)) : sel_VxA( iv, a) String::== tos( b);
        } : genarray( shape( a), true);
  return( res);
}

inline
bool[*] eq_AxA( stringArray a, stringArray b)
{
  res = with {
          ( 0* shape(b) <= iv < shape(b)) : sel_VxA( iv, a) String::== sel_VxA( iv, b);
        } : genarray( shape( b), true);
  return( res);
}

inline
bool[*] (==)( stringArray a, stringArray b)
{
  if( dim(a) ScalarArith::== 0) {
    if( dim( b) ScalarArith::== 0 ) {
      res = eq_SxS( a, b);
    } else {
      res = eq_SxA( a, b);
    }
  } else {
    if( dim(b) ScalarArith::== 0) {
      res = eq_AxS( a, b);
    } else if( all( shape( a) Array::== shape(b))) {
      res = eq_AxA( a, b);
    } else {
      RuntimeError::error( 1, "(==) applied to arrays of different shape!");
      res = false;
    }
  }
  return( res);
}

