module Color8;

use Array: all except { sel, shape, dim} ;
import Array: { sel };
use MathArray : all;
export all except { Weights2Clut, genSteps };

typedef int[3] color;

inline color black()
{
  return( (:color)[0,0,0]);
}

inline color white()
{
  return( (:color)[255,255,255]);
}

inline color red()
{
  return( (:color)[255,0,0]);
}

inline color green()
{
  return( (:color)[0,255,0]);
}

inline color blue()
{
  return( (:color)[0,0,255]);
}

inline color newColor( int[3] col)
{
  min_col = [0, 0, 0];
  max_col = [255, 255, 255];

  col = max( min( col, max_col), min_col);
  return( (:color)col);
}

inline color newColor( int x, int y, int z)
{
  return( newColor( [x,y,z]));
}

inline color[256] Weights2Clut( double[256] w, color c1, color c2)
{
  return( (: color[256]) toi( { iv -> w[iv] * tod((:int[3]) c1) } 
                     + { iv -> (1d - w[iv]) * tod((:int[3]) c2) } ));
}

inline double[256] genSteps( double from, double to)
{
  return( from + tod( iota( 256)) / 256d * ( to - from));
}

inline color[256] genLinearClut( color c1, color c2)
{
  weights = genSteps( 0d, 1d);

  return( Weights2Clut( weights, c1, c2));
}

inline color[256] genLogarithmicClut( double from, double to,
                                      color c1, color c2)
{
  steps = genSteps( from, to);

  weights = (log( steps) - log( from)) / (log( to) - log( from));
  
  return( Weights2Clut( weights, c1, c2));
}

inline color[256] genExponentialClut( double from, double to, 
                                      color c1, color c2)
{
  steps = genSteps( from, to);

  weights = (exp( steps) - exp( from)) / (exp( to) - exp( from));
  
  return( Weights2Clut( weights, c1, c2));
}

inline color[256] genAlternatingClut( color c1, color c2)
{
  res = with {
          ( . <= [i] <= . step [2] ) : c1;
        } : genarray( [256], c2 );

  return( res);
}

inline color[*] sel( int idx, color[*] clut)
{
  return( clut[[idx]]);
}

inline color[*] sel( int[.] idx, color[*] a)
{
  res = Array::sel( idx, ((:int[*])a));
  return( (:color[*])res);
}

inline
int dim( color[*] a)
{
  return( Array::dim((:int[*])a) - 1 );
}

inline
int[.] shape( color[*] a)
{
  return( _drop_SxV_( -1, Array::shape((:int[*])a)) );
}

