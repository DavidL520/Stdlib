module Complex;

export all;

use Math : { atan2 };
use Array : { sel, &, | };

typedef double[2] complex;


  /*  Functions for composing and decomposing of complex numbers.  */




inline double real(complex CPX)
{
  return(((:double[2])CPX)[[0]]);
}


inline double imag(complex CPX)
{
  return(((:double[2])CPX)[[1]]);
}

  /*  
   *  Simple conversion functions between complex, real and integer
   *  numbers.
   */


inline  complex toc(int    REAL, int    IMAG)
{
  return((:complex)[ScalarArith::tod(REAL), ScalarArith::tod(IMAG)]);
}


inline  complex toc(float  REAL, float  IMAG)
{
  return((:complex)[ScalarArith::tod(REAL), ScalarArith::tod(IMAG)]);
}


inline  complex toc(double REAL, double IMAG)
{
  return((:complex)[REAL, IMAG]);
}


/* inlinig results in broken code */
inline complex toc(double[2] COMP)   /* add by jfe */
{
  return((:complex)COMP);

}


inline  complex toc(int    REAL, float  IMAG)
{
  return((:complex)[ScalarArith::tod(REAL), ScalarArith::tod(IMAG)]);
}


inline  complex toc(int    REAL, double IMAG)
{
  return((:complex)[ScalarArith::tod(REAL), IMAG]);
}


inline  complex toc(float  REAL, int    IMAG)
{
  return((:complex)[ScalarArith::tod(REAL), ScalarArith::tod(IMAG)]);
}


inline  complex toc(float  REAL, double IMAG)
{
  return((:complex)[ScalarArith::tod(REAL), IMAG]);
}


inline  complex toc(double REAL, int    IMAG)
{
  return((:complex)[REAL, ScalarArith::tod(IMAG)]);
}


inline  complex toc(double REAL, float  IMAG)
{
  return((:complex)[REAL, ScalarArith::tod(IMAG)]);
}


inline  complex toc(int    REAL)
{
  return((:complex)[ScalarArith::tod(REAL), 0.0d]);
}


inline  complex toc(float  REAL)
{
  return((:complex)[ScalarArith::tod(REAL), 0.0d]);
}


inline complex toc(double REAL)
{
  return((:complex)[REAL, 0.0d]);
}



    /* Create complex number out of real and imag part. */


inline  int,    int    toi(complex C)
{
  return(ScalarArith::toi(real(C)), ScalarArith::toi(imag(C)));
}


inline  float , float  tof(complex C)
{
  return(ScalarArith::tof(real(C)), ScalarArith::tof(imag(C)));
}


inline  double, double tod(complex C)
{
  return(real(C), imag(C));
}

inline  double[2] todv(complex C)
{
  return([real(C), imag(C)]);
}



    /* Extract real and imag part from a complex number. */



  /*  Functions for composing and decomposing of complex numbers
      using polar coordinates.  */


inline complex polar(double MAG, double ANGLE)
{
  return((:complex)[MAG ScalarArith::* Math::cos(ANGLE), MAG ScalarArith::* Math::sin(ANGLE)]);
}

    
inline complex polar(double MAG)
{
  return((:complex)[MAG, 0.0d]);
}

    
inline double norm(complex CPX)
{
  return(  ((:double[2])CPX)[[0]] ScalarArith::* ((:double[2])CPX)[[0]] 
         ScalarArith::+ ((:double[2])CPX)[[1]] ScalarArith::* ((:double[2])CPX)[[1]]);
}


inline double arg(complex CPX)
{
  return(atan2(((:double[2])CPX)[[0]], ((:double[2])CPX)[[1]]));
}



  /*  Complex constants.  */


inline complex zero()
{
  return((:complex)[0.0d, 0.0d]);
}


inline complex one()
{
  return((:complex)[1.0d, 0.0d]);
}


inline complex i()
{
  return((:complex)[0.0d, 1.0d]);
}



  /*  Binary operations on complex numbers.  */

  
inline complex + (complex X1, complex X2)
{
  return((:complex)[((:double[2])X1)[[0]] ScalarArith::+ ((:double[2])X2)[[0]], 
                    ((:double[2])X1)[[1]] ScalarArith::+ ((:double[2])X2)[[1]]]);
}
			 

inline complex + (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] ScalarArith::+ X2, 
                    ((:double[2])X1)[[1]]]);
}


inline complex + (double  X1, complex X2)
{
  return((:complex)[X1 ScalarArith::+ ((:double[2])X2)[[0]], 
                    ((:double[2])X2)[[1]]]);
}

/*
inline complex[+] + (complex[+] X1, complex X2)
{
  res = with (. <= iv <= .)
       	genarray( drop([-1],shape(X1)), ((:complex)((:double[+])X1)[iv]) ScalarArith::+ X2); 
  return(res);  
}
*/

inline complex - (complex X1, complex X2)
{
  return((:complex)[((:double[2])X1)[[0]] ScalarArith::- ((:double[2])X2)[[0]],
                    ((:double[2])X1)[[1]] ScalarArith::- ((:double[2])X2)[[1]]]);
}


inline complex - (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] ScalarArith::- X2, 
                    ((:double[2])X1)[[1]]]);
}


inline complex - (double  X1, complex X2)
{
  return((:complex)[X1 ScalarArith::- ((:double[2])X2)[[0]], 
                    ((:double[2])X2)[[1]]]);
}

inline complex * (complex X1, complex X2)
{
  return((:complex)[((:double[2])X1)[[0]] ScalarArith::* ((:double[2])X2)[[0]] 
                    ScalarArith::- ((:double[2])X1)[[1]] ScalarArith::* ((:double[2])X2)[[1]],
                    ((:double[2])X1)[[0]] ScalarArith::* ((:double[2])X2)[[1]] 
                    ScalarArith::+ ((:double[2])X1)[[1]] ScalarArith::* ((:double[2])X2)[[0]]]);
}


inline complex * (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] ScalarArith::* X2, 
                    ((:double[2])X1)[[1]] ScalarArith::* X2]);
}


inline complex * (double  X1, complex X2)
{
  return((:complex)[X1 ScalarArith::* ((:double[2])X2)[[0]],
                    X1 ScalarArith::* ((:double[2])X2)[[1]]]);
}


inline complex / (complex X1, complex X2)
{
  Z = ((:double[2])X2)[[0]] ScalarArith::* ((:double[2])X2)[[0]] 
      ScalarArith::+ ((:double[2])X2)[[1]] ScalarArith::* ((:double[2])X2)[[1]];
  
  return((:complex)[(((:double[2])X1)[[0]] ScalarArith::* ((:double[2])X2)[[0]]
                      ScalarArith::+ ((:double[2])X1)[[1]] ScalarArith::* ((:double[2])X2)[[1]])
                    ScalarArith::/ Z,
                    (((:double[2])X1)[[1]] ScalarArith::* ((:double[2])X2)[[0]]
                      ScalarArith::- ((:double[2])X1)[[0]] ScalarArith::* ((:double[2])X2)[[1]])
                    ScalarArith::/ Z]);
}


inline complex / (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] ScalarArith::/ X2,
                    ((:double[2])X1)[[1]] ScalarArith::/ X2]);
}


inline complex / (double  X1, complex X2)
{
  Z = ((:double[2])X2)[[0]] ScalarArith::* ((:double[2])X2)[[0]] 
      ScalarArith::+ ((:double[2])X2)[[1]] ScalarArith::* ((:double[2])X2)[[1]];
  
  return((:complex)[X1 ScalarArith::* ((:double[2])X2)[[0]] ScalarArith::/ Z, 
                    0d ScalarArith::- X1 ScalarArith::* ((:double[2])X2)[[1]] ScalarArith::/ Z]);
}


  
inline bool == (complex X1, complex X2)
{
  return((((:double[2])X1)[[0]] ScalarArith::== ((:double[2])X2)[[0]]) 
         & (((:double[2])X1)[[1]] ScalarArith::== ((:double[2])X2)[[1]]));
}


inline bool == (complex X1, double  X2)
{
  return((((:double[2])X1)[[0]] ScalarArith::== X2) 
         & (((:double[2])X1)[[1]] ScalarArith::== 0.0d));
}


inline bool == (double  X1, complex X2)
{
  return((X1 ScalarArith::== ((:double[2])X2)[[0]]) 
         & (0.0d ScalarArith::== ((:double[2])X2)[[1]]));
}


inline bool != (complex X1, complex X2)
{
  return((((:double[2])X1)[[0]] ScalarArith::!= ((:double[2])X2)[[0]])
         | (((:double[2])X1)[[1]] ScalarArith::!= ((:double[2])X2)[[1]]));
}


inline bool != (complex X1, double  X2)
{
  return((((:double[2])X1)[[0]] ScalarArith::!= X2)
         | (((:double[2])X1)[[1]] ScalarArith::!= 0.0d));
}


inline bool != (double  X1, complex X2)
{
  return((X1 ScalarArith::!= ((:double[2])X2)[[0]])
         | (0.0d ScalarArith::!= ((:double[2])X2)[[1]]));
}




  /*  Functions for specific complex manipulations. */

  
inline complex conj(complex X)
{
  return((:complex)[((:double[2])X)[[0]], (0d ScalarArith::- 1.0d) ScalarArith::* ((:double[2])X)[[1]]]);
}


inline double abs(complex X)
{
  return(Math::sqrt(((:double[2])X)[[0]] ScalarArith::* ((:double[2])X)[[0]]
              ScalarArith::+ ((:double[2])X)[[1]] ScalarArith::* ((:double[2])X)[[1]]));
}




/*
 *  The following function definitions are based on
 *
 *  Bronstein/Semendjajew: Taschenbuch der Mathematik, page 512ff
 */



  /*  Trigonometric functions on complex numbers.  */


inline complex sin(complex X)
{
  return((:complex)[Math::sin(((:double[2])X)[[0]]) ScalarArith::* Math::cosh(((:double[2])X)[[1]]),
                    Math::cos(((:double[2])X)[[0]]) ScalarArith::* Math::sinh(((:double[2])X)[[1]])]);
}


inline complex cos(complex X)
{
  return((:complex)[Math::cos(((:double[2])X)[[0]]) ScalarArith::* Math::cosh(((:double[2])X)[[1]]), 
                    (0d ScalarArith::- 1.0d) ScalarArith::* Math::sin(((:double[2])X)[[0]]) 
                         ScalarArith::* Math::sinh(((:double[2])X)[[1]])]);
}


inline complex tan(complex X)
{
  Z = Math::cos(2.0d ScalarArith::*((:double[2])X)[[0]]) ScalarArith::+ Math::cosh(2.0d ScalarArith::* ((:double[2])X)[[1]]);
  
  return((:complex)[Math::sin(2d ScalarArith::*((:double[2])X)[[0]])  ScalarArith::/ Z, 
                    Math::sinh(2d ScalarArith::*((:double[2])X)[[1]])  ScalarArith::/ Z]);
}


inline complex asin(complex X)
{
  return((0d ScalarArith::- 1.0d) * i() * log(i() * X + sqrt(1.0d - X * X)));
}


inline complex acos(complex X)
{
  return((0d ScalarArith::- 1.0d) * i() * log(X + sqrt(X * X - 1.0d)));
}


inline complex atan(complex X)
{
  return((1.0d / (2.0d * i())) * log((1.0d + i() * X) / (1.0d - i() * X)));
}



  /* Hyperbolic functions on complex numbers.  */


inline complex sinh(complex X)
{
  return((:complex)[Math::sinh(((:double[2])X)[[0]]) ScalarArith::* Math::cos(((:double[2])X)[[1]]),
                    Math::cosh(((:double[2])X)[[0]]) ScalarArith::* Math::sin(((:double[2])X)[[1]])]);
}


inline complex cosh(complex X)
{
  return((:complex)[Math::cosh(((:double[2])X)[[0]]) ScalarArith::* Math::cos(((:double[2])X)[[1]]),
                    Math::sinh(((:double[2])X)[[0]]) ScalarArith::* Math::sin(((:double[2])X)[[1]])]);
}


inline complex tanh(complex X)
{
  return(sinh(X) / cosh(X));
}


inline complex asinh(complex X)
{
  return( log(X + sqrt(X * X + 1.0d)));
}


inline complex acosh(complex X)
{
  return(log(X + sqrt(X*X-1.0d)));
}


inline complex atanh(complex X)
{
  return(0.5d * log((1.0d + X) / (1.0d - X)));
}





  /* Exponential and logarithmic functions on complex numbers.  */


inline complex exp(complex X)
{
  return((:complex)[Math::exp(((:double[2])X)[[0]]) ScalarArith::* Math::cos(((:double[2])X)[[1]]),
                    Math::exp(((:double[2])X)[[0]]) ScalarArith::* Math::sin(((:double[2])X)[[1]])]);
}


inline complex log(complex X)
{
  return((:complex)[0.5d
                    ScalarArith::* Math::log(((:double[2])X)[[0]] ScalarArith::* ((:double[2])X)[[0]]
                          ScalarArith::+ ((:double[2])X)[[1]] ScalarArith::* ((:double[2])X)[[1]]),
                    Math::atan(((:double[2])X)[[1]] ScalarArith::/ ((:double[2])X)[[0]])]);
}




  /* Power functions on complex numbers.  */


inline complex pow(complex BASE, complex EXPON)
{
  return(exp(EXPON * log(BASE)));
}


inline complex pow(complex BASE, double  EXPON)
{
  return(exp(EXPON * log(BASE)));
}


inline complex pow(double  BASE, complex EXPON)
{
  return(exp(EXPON * Math::log(BASE)));
}


inline complex sqrt(complex X)
{
  return((:complex)[Math::sqrt(0.5d ScalarArith::* 
                    (((:double[2])X)[[0]] 
                     ScalarArith::+ Math::sqrt(((:double[2])X)[[0]] ScalarArith::* ((:double[2])X)[[0]]
                            ScalarArith::+ ((:double[2])X)[[1]] ScalarArith::* ((:double[2])X)[[1]]))),
                    Math::sqrt(0.5d ScalarArith::* 
		    ((0d ScalarArith::- 1.0d) ScalarArith::* ((:double[2])X)[[0]]
                     ScalarArith::+ Math::sqrt(((:double[2])X)[[0]] 
                              ScalarArith::* ((:double[2])X)[[0]]
                            ScalarArith::+ ((:double[2])X)[[1]]
                              ScalarArith::* ((:double[2])X)[[1]])))]);
}







