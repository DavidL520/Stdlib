Module Complex:

import Math: all;

typedef double[2] complex;


  /*  Functions for composing and decomposing of complex numbers.  */




inline double real(complex CPX)
{
  return(((:double[2])CPX)[[0]]);
}


inline double imag(complex CPX)
{
  return(((:double[2])CPX)[[1]]);
}

  /*  
   *  Simple conversion functions between complex, real and integer
   *  numbers.
   */


inline  complex toc(int    REAL, int    IMAG)
{
  return((:complex)[tod(REAL), tod(IMAG)]);
}


inline  complex toc(float  REAL, float  IMAG)
{
  return((:complex)[tod(REAL), tod(IMAG)]);
}


inline  complex toc(double REAL, double IMAG)
{
  return((:complex)[REAL, IMAG]);
}


/* inlinig results in broken code */
inline complex toc(double[2] COMP)   /* add by jfe */
{
  return((:complex)COMP);

}


inline  complex toc(int    REAL, float  IMAG)
{
  return((:complex)[tod(REAL), tod(IMAG)]);
}


inline  complex toc(int    REAL, double IMAG)
{
  return((:complex)[tod(REAL), IMAG]);
}


inline  complex toc(float  REAL, int    IMAG)
{
  return((:complex)[tod(REAL), tod(IMAG)]);
}


inline  complex toc(float  REAL, double IMAG)
{
  return((:complex)[tod(REAL), IMAG]);
}


inline  complex toc(double REAL, int    IMAG)
{
  return((:complex)[REAL, tod(IMAG)]);
}


inline  complex toc(double REAL, float  IMAG)
{
  return((:complex)[REAL, tod(IMAG)]);
}


inline  complex toc(int    REAL)
{
  return((:complex)[tod(REAL), 0.0d]);
}


inline  complex toc(float  REAL)
{
  return((:complex)[tod(REAL), 0.0d]);
}


inline complex toc(double REAL)
{
  return((:complex)[REAL, 0.0d]);
}



    /* Create complex number out of real and imag part. */


inline  int,    int    toi(complex C)
{
  return(toi(real(C)), toi(imag(C)));
}


inline  float , float  tof(complex C)
{
  return(tof(real(C)), tof(imag(C)));
}


inline  double, double tod(complex C)
{
  return(real(C), imag(C));
}

inline  double[2] todv(complex C)
{
  return([real(C), imag(C)]);
}



    /* Extract real and imag part from a complex number. */



  /*  Functions for composing and decomposing of complex numbers
      using polar coordinates.  */


inline complex polar(double MAG, double ANGLE)
{
  return((:complex)[MAG*cos(ANGLE), MAG*sin(ANGLE)]);
}

    
inline complex polar(double MAG)
{
  return((:complex)[MAG, 0.0d]);
}

    
inline double norm(complex CPX)
{
  return(  ((:double[2])CPX)[[0]] * ((:double[2])CPX)[[0]] 
         + ((:double[2])CPX)[[1]] * ((:double[2])CPX)[[1]]);
}


inline double arg(complex CPX)
{
  return(atan2(((:double[2])CPX)[[0]], ((:double[2])CPX)[[1]]));
}



  /*  Complex constants.  */


inline complex zero()
{
  return((:complex)[0.0d, 0.0d]);
}


inline complex one()
{
  return((:complex)[1.0d, 0.0d]);
}


inline complex i()
{
  return((:complex)[0.0d, 1.0d]);
}



  /*  Binary operations on complex numbers.  */

  
inline complex + (complex X1, complex X2)
{
  return((:complex)[((:double[2])X1)[[0]] + ((:double[2])X2)[[0]], 
                    ((:double[2])X1)[[1]] + ((:double[2])X2)[[1]]]);
}
			 

inline complex + (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] + X2, 
                    ((:double[2])X1)[[1]]]);
}


inline complex + (double  X1, complex X2)
{
  return((:complex)[X1 + ((:double[2])X2)[[0]], 
                    ((:double[2])X2)[[1]]]);
}


inline complex - (complex X1, complex X2)
{
  return((:complex)[((:double[2])X1)[[0]] - ((:double[2])X2)[[0]],
                    ((:double[2])X1)[[1]] - ((:double[2])X2)[[1]]]);
}


inline complex - (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] - X2, 
                    ((:double[2])X1)[[1]]]);
}


inline complex - (double  X1, complex X2)
{
  return((:complex)[X1 - ((:double[2])X2)[[0]], 
                    ((:double[2])X2)[[1]]]);
}


inline complex * (complex X1, complex X2)
{
  return((:complex)[((:double[2])X1)[[0]] * ((:double[2])X2)[[0]] 
                    - ((:double[2])X1)[[1]] * ((:double[2])X2)[[1]],
                    ((:double[2])X1)[[0]] * ((:double[2])X2)[[1]] 
                    + ((:double[2])X1)[[1]] * ((:double[2])X2)[[0]]]);
}


inline complex * (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] * X2, 
                    ((:double[2])X1)[[1]] * X2]);
}


inline complex * (double  X1, complex X2)
{
  return((:complex)[X1 * ((:double[2])X2)[[0]],
                    X1 * ((:double[2])X2)[[1]]]);
}


inline complex / (complex X1, complex X2)
{
  Z = ((:double[2])X2)[[0]] * ((:double[2])X2)[[0]] 
      + ((:double[2])X2)[[1]] * ((:double[2])X2)[[1]];
  
  return((:complex)[(((:double[2])X1)[[0]] * ((:double[2])X2)[[0]]
                      + ((:double[2])X1)[[1]] * ((:double[2])X2)[[1]])
                    / Z,
                    (((:double[2])X1)[[1]] * ((:double[2])X2)[[0]]
                      - ((:double[2])X1)[[0]] * ((:double[2])X2)[[1]])
                    / Z]);
}


inline complex / (complex X1, double  X2)
{
  return((:complex)[((:double[2])X1)[[0]] / X2,
                    ((:double[2])X1)[[1]] / X2]);
}


inline complex / (double  X1, complex X2)
{
  Z = ((:double[2])X2)[[0]] * ((:double[2])X2)[[0]] 
      + ((:double[2])X2)[[1]] * ((:double[2])X2)[[1]];
  
  return((:complex)[X1 * ((:double[2])X2)[[0]] / Z, 
                    - X1 * ((:double[2])X2)[[1]] / Z]);
}


  
inline bool == (complex X1, complex X2)
{
  return((((:double[2])X1)[[0]] == ((:double[2])X2)[[0]]) 
         && (((:double[2])X1)[[1]] == ((:double[2])X2)[[1]]));
}


inline bool == (complex X1, double  X2)
{
  return((((:double[2])X1)[[0]] == X2) 
         && (((:double[2])X1)[[1]] == 0.0d));
}


inline bool == (double  X1, complex X2)
{
  return((X1 == ((:double[2])X2)[[0]]) 
         && (0.0d == ((:double[2])X2)[[1]]));
}


inline bool != (complex X1, complex X2)
{
  return((((:double[2])X1)[[0]] != ((:double[2])X2)[[0]])
         || (((:double[2])X1)[[1]] != ((:double[2])X2)[[1]]));
}


inline bool != (complex X1, double  X2)
{
  return((((:double[2])X1)[[0]] != X2)
         || (((:double[2])X1)[[1]] != 0.0d));
}


inline bool != (double  X1, complex X2)
{
  return((X1 != ((:double[2])X2)[[0]])
         || (0.0d != ((:double[2])X2)[[1]]));
}




  /*  Functions for specific complex manipulations. */

  
inline complex conj(complex X)
{
  return((:complex)[((:double[2])X)[[0]], (-1.0d) * ((:double[2])X)[[1]]]);
}


inline double abs(complex X)
{
  return(sqrt(((:double[2])X)[[0]] * ((:double[2])X)[[0]]
              + ((:double[2])X)[[1]] * ((:double[2])X)[[1]]));
}




/*
 *  The following function definitions are based on
 *
 *  Bronstein/Semendjajew: Taschenbuch der Mathematik, page 512ff
 */



  /*  Trigonometric functions on complex numbers.  */


inline complex sin(complex X)
{
  return((:complex)[sin(((:double[2])X)[[0]]) * cosh(((:double[2])X)[[1]]),
                    cos(((:double[2])X)[[0]]) * sinh(((:double[2])X)[[1]])]);
}


inline complex cos(complex X)
{
  return((:complex)[cos(((:double[2])X)[[0]]) * cosh(((:double[2])X)[[1]]), 
                    (-1.0d) * sin(((:double[2])X)[[0]]) 
                         * sinh(((:double[2])X)[[1]])]);
}


inline complex tan(complex X)
{
  Z = cos(2.0d*((:double[2])X)[[0]]) + cosh(2.0d*((:double[2])X)[[1]]);
  
  return((:complex)[sin(2*((:double[2])X)[[0]]) / Z, 
                    sinh(2*((:double[2])X)[[1]]) / Z]);
}


inline complex asin(complex X)
{
  return((-1.0d)*i()*log(i()*X + sqrt(1.0d-X*X)));
}


inline complex acos(complex X)
{
  return((-1.0d)*i()*log(X + sqrt(X*X-1.0d)));
}


inline complex atan(complex X)
{
  return((1.0d/(2.0d*i())) * log((1.0d+i()*X) / (1.0d-i()*X)));
}



  /* Hyperbolic functions on complex numbers.  */


inline complex sinh(complex X)
{
  return((:complex)[sinh(((:double[2])X)[[0]]) * cos(((:double[2])X)[[1]]),
                    cosh(((:double[2])X)[[0]]) * sin(((:double[2])X)[[1]])]);
}


inline complex cosh(complex X)
{
  return((:complex)[cosh(((:double[2])X)[[0]]) * cos(((:double[2])X)[[1]]),
                    sinh(((:double[2])X)[[0]]) * sin(((:double[2])X)[[1]])]);
}


inline complex tanh(complex X)
{
  return(sinh(X)/cosh(X));
}


inline complex asinh(complex X)
{
  return(log(X + sqrt(X*X+1.0d)));
}


inline complex acosh(complex X)
{
  return(log(X + sqrt(X*X-1.0d)));
}


inline complex atanh(complex X)
{
  return(0.5d * log((1.0d+X) / (1.0d-X)));
}





  /* Exponential and logarithmic functions on complex numbers.  */


inline complex exp(complex X)
{
  return((:complex)[exp(((:double[2])X)[[0]]) * cos(((:double[2])X)[[1]]),
                    exp(((:double[2])X)[[0]]) * sin(((:double[2])X)[[1]])]);
}


inline complex log(complex X)
{
  return((:complex)[0.5d
                    * log(((:double[2])X)[[0]] * ((:double[2])X)[[0]]
                          + ((:double[2])X)[[1]] * ((:double[2])X)[[1]]),
                    atan(((:double[2])X)[[1]] / ((:double[2])X)[[0]])]);
}




  /* Power functions on complex numbers.  */


inline complex pow(complex BASE, complex EXPON)
{
  return(exp(EXPON * log(BASE)));
}


inline complex pow(complex BASE, double  EXPON)
{
  return(exp(EXPON * log(BASE)));
}


inline complex pow(double  BASE, complex EXPON)
{
  return(exp(EXPON * log(BASE)));
}


inline complex sqrt(complex X)
{
  return((:complex)[sqrt(0.5d * 
                    (((:double[2])X)[[0]] 
                     + sqrt(((:double[2])X)[[0]] * ((:double[2])X)[[0]]
                            + ((:double[2])X)[[1]] * ((:double[2])X)[[1]]))),
                    sqrt(0.5d * 
		    ((-1.0d) * ((:double[2])X)[[0]]
                     + sqrt(((:double[2])X)[[0]] 
                              * ((:double[2])X)[[0]]
                            + ((:double[2])X)[[1]]
                              * ((:double[2])X)[[1]])))]);
}









